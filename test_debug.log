============================= test session starts =============================
platform win32 -- Python 3.12.1, pytest-9.0.1, pluggy-1.6.0 -- C:\Users\pablo\AppData\Local\Programs\Python\Python312\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\pablo\Movistar Cloud\Gravity\blurtpy
configfile: pytest.ini
collecting ... collected 10 items

tests/test_native_blurt.py::TestNativeBlurt::test_01_connection_and_props PASSED [ 10%]
tests/test_native_blurt.py::TestNativeBlurt::test_02_account_fetch_integrity PASSED [ 20%]
tests/test_native_blurt.py::TestNativeBlurt::test_03_account_not_found PASSED [ 30%]
tests/test_native_blurt.py::TestNativeBlurt::test_04_transaction_signing PASSED [ 40%]
tests/test_native_blurt.py::TestNativeBlurt::test_05_missing_key_protection PASSED [ 50%]
tests/test_native_blurt.py::TestNativeBlurt::test_06_history_resilience PASSED [ 60%]
tests/test_native_blurt.py::TestNativeBlurt::test_07_memo_encryption FAILED [ 70%]
tests/test_native_blurt.py::TestNativeBlurt::test_08_power_up_dry_run FAILED [ 80%]
tests/test_native_blurt.py::TestNativeBlurt::test_09_claim_rewards_dry_run FAILED [ 90%]
tests/test_native_blurt.py::TestNativeBlurt::test_10_vote_operation_dry_run FAILED [100%]

================================== FAILURES ===================================
___________________ TestNativeBlurt.test_07_memo_encryption ___________________

self = <tests.test_native_blurt.TestNativeBlurt testMethod=test_07_memo_encryption>

    def test_07_memo_encryption(self):
        """
        CRYPTO: Test Memo encryption and decryption using ephemeral keys.
        This verifies the AES encryption logic without needing account keys.
        """
        logger.info("Testing Memo encryption/decryption...")
        from blurtpy.memo import Memo
        from blurtgraphenebase.account import PasswordKey
    
        # Generate two temporary keys
        sender_wif = PasswordKey("sender", "password", role="memo").get_private_key()
        receiver_wif = PasswordKey("receiver", "password", role="memo").get_private_key()
        receiver_pub = receiver_wif.pubkey
    
        # Initialize Memo with these keys
        # We pass keys directly to avoid looking up accounts on chain
>       memo_obj = Memo(
            from_account=sender_wif,
            to_account=receiver_pub,
            blockchain_instance=self.blurt
        )

tests\test_native_blurt.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <blurtpy.memo.Memo object at 0x00000275FAEDBDD0>
from_account = <PrivateKey: STM8WTxgAg5Wwxk9rpYkUXG4NqoT5KWntKnCqmsuQ3yuS5yMoHZSz>
to_account = 02ca15d3b891abd4a39a8b8a49b136ef372a0f02c0be54863b435367c24cf85655
blockchain_instance = <Blurt node=https://rpc.blurt.world, nobroadcast=False>
kwargs = {}

    def __init__(
        self,
        from_account=None,
        to_account=None,
        blockchain_instance=None,
        **kwargs
    ):
        if blockchain_instance is None:
            if kwargs.get("blurt_instance"):
                blockchain_instance = kwargs["blurt_instance"]
            elif kwargs.get("blurt_instance"):
                blockchain_instance = kwargs["blurt_instance"]
        self.blockchain = blockchain_instance or shared_blockchain_instance()
    
>       if to_account and len(to_account) < 51:
                          ^^^^^^^^^^^^^^^
E       TypeError: object of type 'PublicKey' has no len()

blurtpy\memo.py:149: TypeError
__________________ TestNativeBlurt.test_08_power_up_dry_run ___________________

self = <tests.test_native_blurt.TestNativeBlurt testMethod=test_08_power_up_dry_run>

    def test_08_power_up_dry_run(self):
        """
        OPERATION: Construct and sign a Transfer to Vesting (Power Up) operation.
        """
        logger.info("Testing Power Up (dry-run)...")
        # transfer_to_vesting(amount, to, account)
>       tx = self.blurt.transfer_to_vesting(
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            0.001, ACCOUNT_NAME, account=ACCOUNT_NAME, nobroadcast=True
        )
E       AttributeError: 'Blurt' object has no attribute 'transfer_to_vesting'

tests\test_native_blurt.py:159: AttributeError
________________ TestNativeBlurt.test_09_claim_rewards_dry_run ________________

self = <tests.test_native_blurt.TestNativeBlurt testMethod=test_09_claim_rewards_dry_run>

    def test_09_claim_rewards_dry_run(self):
        """
        OPERATION: Construct and sign a Claim Reward Balance operation.
        """
        logger.info("Testing Claim Rewards (dry-run)...")
        # claim_reward_balance(reward_blurt, reward_vests, account)
>       tx = self.blurt.claim_reward_balance(
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            0, 0, account=ACCOUNT_NAME, nobroadcast=True
        )
E       AttributeError: 'Blurt' object has no attribute 'claim_reward_balance'

tests\test_native_blurt.py:171: AttributeError
_______________ TestNativeBlurt.test_10_vote_operation_dry_run ________________

self = <blurtapi.noderpc.NodeRPC object at 0x00000275FAEDBF20>
payload = {'id': 20, 'jsonrpc': '2.0', 'method': 'call', 'params': ['condenser_api', 'broadcast_transaction', [{'expiration': '2025-11-30T11:18:57', 'extensions': [], 'operations': [['vote', {...}]], 'ref_block_num': 13463, ...}]]}

    def rpcexec(self, payload):
        """ Execute a call by sending the payload.
            It makes use of the GrapheneRPC library.
            In here, we mostly deal with Blurt specific error handling
    
            :param json payload: Payload data
            :raises ValueError: if the server does not respond in proper JSON format
            :raises RPCError: if the server returns an error
        """
        if self.url is None:
            raise exceptions.RPCConnection("RPC is not connected!")
        doRetry = True
        maxRetryCountReached = False
        while doRetry and not maxRetryCountReached:
            doRetry = False
            try:
                # Forward call to GrapheneWebsocketRPC and catch+evaluate errors
>               reply = super(NodeRPC, self).rpcexec(payload)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

blurtapi\noderpc.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <blurtapi.noderpc.NodeRPC object at 0x00000275FAEDBF20>
payload = {'id': 20, 'jsonrpc': '2.0', 'method': 'call', 'params': ['condenser_api', 'broadcast_transaction', [{'expiration': '2025-11-30T11:18:57', 'extensions': [], 'operations': [['vote', {...}]], 'ref_block_num': 13463, ...}]]}

    def rpcexec(self, payload):
        """
        Execute a call by sending the payload.
    
        :param json payload: Payload data
        :raises ValueError: if the server does not respond in proper JSON format
        :raises RPCError: if the server returns an error
        """
        log.debug(json.dumps(payload))
        if self.nodes.working_nodes_count == 0:
            raise WorkingNodeMissing
        if self.url is None:
            raise RPCConnection("RPC is not connected!")
        reply = {}
        response = None
        while True:
            self.nodes.increase_error_cnt_call()
            try:
                if self.current_rpc == self.rpc_methods['ws'] or \
                   self.current_rpc == self.rpc_methods['wsappbase']:
                    reply = self.ws_send(json.dumps(payload, ensure_ascii=False).encode('utf8'))
                else:
                    response = self.request_send(json.dumps(payload, ensure_ascii=False).encode('utf8'))
                    reply = response.text
                if not bool(reply):
                    try:
                        self.nodes.sleep_and_check_retries("Empty Reply", call_retry=True)
                    except CallRetriesReached:
                        self.nodes.increase_error_cnt()
                        self.nodes.sleep_and_check_retries("Empty Reply", sleep=False, call_retry=False)
                        self.rpcconnect()
                else:
                    break
            except KeyboardInterrupt:
                raise
            except WebSocketConnectionClosedException as e:
                if self.nodes.num_retries_call_reached:
                    self.nodes.increase_error_cnt()
                    self.nodes.sleep_and_check_retries(str(e), sleep=False, call_retry=False)
                    self.rpcconnect()
                else:
                    # self.nodes.sleep_and_check_retries(str(e), sleep=True, call_retry=True)
                    self.rpcconnect(next_url=False)
            except ConnectionError as e:
                self.nodes.increase_error_cnt()
                self.nodes.sleep_and_check_retries(str(e), sleep=False, call_retry=False)
                self.rpcconnect()
            except WebSocketTimeoutException as e:
                self.nodes.increase_error_cnt()
                self.nodes.sleep_and_check_retries(str(e), sleep=False, call_retry=False)
                self.rpcconnect()
            except Exception as e:
                self.nodes.increase_error_cnt()
                self.nodes.sleep_and_check_retries(str(e), sleep=False, call_retry=False)
                self.rpcconnect()
    
        ret = {}
        try:
            if response is None:
                ret = json.loads(reply, strict=False, encoding="utf-8")
            else:
                ret = response.json()
        except ValueError:
            self._check_for_server_error(reply)
    
        log.debug(json.dumps(reply))
    
        if isinstance(ret, dict) and 'error' in ret:
            if 'detail' in ret['error']:
                raise RPCError(ret['error']['detail'])
            else:
>               raise RPCError(ret['error']['message'])
E               blurtapi.exceptions.RPCError: unknown key:unknown key:

blurtapi\graphenerpc.py:457: RPCError

During handling of the above exception, another exception occurred:

self = <tests.test_native_blurt.TestNativeBlurt testMethod=test_10_vote_operation_dry_run>

    def test_10_vote_operation_dry_run(self):
        """
        OPERATION: Construct and sign a Vote operation.
        Validates posting authority logic (even if using Active key).
        """
        logger.info("Testing Vote operation (dry-run)...")
        # vote(identifier, weight, account)
        # Using a known valid identifier (or random, since it's dry-run structure check)
        # We use a real-looking identifier to pass validation if any
        identifier = "@draktest/test-post"
>       tx = self.blurt.vote(
            identifier, 100, account=ACCOUNT_NAME, nobroadcast=True
        )

tests\test_native_blurt.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
blurtpy\blurt.py:513: in vote
    return Account(account, blockchain_instance=self).vote(identifier, weight, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
blurtpy\account.py:2930: in vote
    return self.blockchain.finalizeOp(op, account, "posting", **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
blurtpy\blockchaininstance.py:938: in finalizeOp
    ret = self.txbuffer.broadcast()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
blurtpy\transactionbuilder.py:558: in broadcast
    raise e
blurtpy\transactionbuilder.py:553: in broadcast
    self.blockchain.rpc.broadcast_transaction(
blurtapi\graphenerpc.py:508: in method
    r = self.rpcexec(query)
        ^^^^^^^^^^^^^^^^^^^
blurtapi\noderpc.py:84: in rpcexec
    doRetry = self._check_error_message(e, self.error_cnt_call)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <blurtapi.noderpc.NodeRPC object at 0x00000275FAEDBF20>
e = RPCError('unknown key:unknown key: '), cnt = 1

    def _check_error_message(self, e, cnt):
        """Check error message and decide what to do"""
        doRetry = False
        msg = exceptions.decodeRPCErrorMsg(e).strip()
        if re.search("missing required active authority", msg):
            raise exceptions.MissingRequiredActiveAuthority
        elif re.match("^no method with name.*", msg):
            raise exceptions.NoMethodWithName(msg)
        elif re.search("Could not find method", msg):
            raise exceptions.NoMethodWithName(msg)
        elif re.search("Unknown Transaction", msg):
            raise exceptions.UnknownTransaction(msg)
        elif re.search("Could not find API", msg):
            if self._check_api_name(msg):
                if self.nodes.working_nodes_count > 1 and self.nodes.num_retries > -1:
                    self.nodes.disable_node()
                    self._switch_to_next_node(msg, "ApiNotSupported")
                    doRetry = True
                else:
                    raise exceptions.ApiNotSupported(msg)
            else:
                raise exceptions.NoApiWithName(msg)
        elif re.search("follow_api_plugin not enabled", msg):
            if self.nodes.working_nodes_count > 1 and self.nodes.num_retries > -1:
                self._switch_to_next_node(str(e))
                doRetry = True
            else:
                raise exceptions.FollowApiNotEnabled(msg)
        elif re.search("irrelevant signature included", msg):
            raise exceptions.UnnecessarySignatureDetected(msg)
        elif re.search("WinError", msg):
            raise exceptions.RPCError(msg)
        elif re.search("Invalid parameters", msg):
            raise exceptions.InvalidParameters()
        elif re.search("Supported by Blurtmind", msg):
            raise exceptions.SupportedByBlurtmind()
        elif re.search("Could not find filtered operation", msg):
            raise exceptions.FilteredItemNotFound(msg)
        elif re.search("Unable to acquire database lock", msg):
            self.nodes.sleep_and_check_retries(str(msg), call_retry=True)
            doRetry = True
        elif re.search("Request Timeout", msg):
            self.nodes.sleep_and_check_retries(str(msg), call_retry=True)
            doRetry = True
        elif re.search("Bad or missing upstream response", msg):
            self.nodes.sleep_and_check_retries(str(msg), call_retry=True)
            doRetry = True
        elif re.search("Internal Error", msg) or re.search("Unknown exception", msg):
            self.nodes.sleep_and_check_retries(str(msg), call_retry=True)
            doRetry = True
        elif re.search("!check_max_block_age", str(e)):
            self._switch_to_next_node(str(e))
            doRetry = True
        elif re.search("Server error", str(e)):
            self._switch_to_next_node(str(e))
            doRetry = True
        elif re.search("Can only vote once every 3 seconds", msg):
            raise exceptions.VotedBeforeWaitTimeReached(msg)
        elif re.search("out_of_rangeEEEE: unknown key", msg) or re.search("unknown key:unknown key", msg):
>           raise exceptions.UnkownKey(msg)
E           blurtapi.exceptions.UnkownKey: unknown key:unknown key:

blurtapi\noderpc.py:163: UnkownKey
---------------------------- Captured stdout call -----------------------------
[DEBUG] Chain ID: cd8d90f29ae273abec3eaa7731e25934c63eb654d55080caff2ebb7f5df6381f
[DEBUG] Serialized Tx (hex): 9734584e0e2521282c690100086472616b74657374086472616b7465737409746573742d706f7374102700
[DEBUG] Full Message (ChainID + Tx) (hex): cd8d90f29ae273abec3eaa7731e25934c63eb654d55080caff2ebb7f5df6381f9734584e0e2521282c690100086472616b74657374086472616b7465737409746573742d706f7374102700
[DEBUG] Digest (SHA256) (hex): 8087098586cc8bc7b3663c831ddffbdbf7040e70e14a441a3897c3e9b18e173d
========================= 4 failed, 6 passed in 5.90s =========================
